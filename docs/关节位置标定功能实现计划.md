# 关节位置标定功能实现计划

**版本：** v1.0  
**日期：** 2025-12-22  
**功能：** 读取0位 + 最大位置读取

---

## 1. 功能概述

### 1.1 功能需求

**功能1：读取0位（归零位置标定）**
- 从串口读取各电机当前位置
- 将当前位置设置为归零参考点（0位）
- 保存归零偏移量到配置文件

**功能2：读取最大位置（行程标定）**
- 从串口读取各电机当前位置
- 计算相对于0位的最大行程
- 保存最大位置限制到配置文件

### 1.2 应用场景

**归零位置标定：**
- 系统初始化时，机器人处于已知安全姿态
- 用户手动调整机器人到初始位置后标定
- 重新校准机器人坐标系统

**最大位置标定：**
- 标定各关节的运动范围
- 设置软限位的上限
- 用于轨迹规划的边界约束

---

## 2. UI界面设计

### 2.1 主界面布局调整

在主控制界面添加标定功能区：

```
┌─────────────────────────────────────────────────────┐
│  [工具栏] [连接] [断开] [急停] [复位] [录制] [回放] │
├─────────────────────────────────────────────────────┤
│  [新增] 标定工具栏                                   │
│  [读取0位] [读取最大位] [保存标定] [标定向导]       │
├──────────────────┬──────────────────────────────────┤
│  关节控制面板     │   状态监控面板                    │
│  ┌────────────┐  │   ┌──────────────────────────┐  │
│  │ 手指1 [滑块]│  │   │ 当前位置: 1500           │  │
│  │   0位: 100  │  │   │ 0位参考: 100             │  │
│  │   最大: 2800│  │   │ 最大位置: 2800           │  │
│  │ 手指2 [滑块]│  │   │ 行程范围: 2700           │  │
│  └────────────┘  │   └──────────────────────────┘  │
└──────────────────┴──────────────────────────────────┘
```

### 2.2 标定对话框设计

**标定向导对话框（步骤1 - 读取0位）：**

```
┌─────────────────────────────────────────┐
│  关节位置标定向导                        │
├─────────────────────────────────────────┤
│  步骤 1/2: 读取归零位置                  │
│                                          │
│  请将机器人移动到初始位置（0位）         │
│  然后点击"读取当前位置"按钮              │
│                                          │
│  ┌────────────────────────────────────┐ │
│  │ 关节    当前位置   将设为0位       │ │
│  │ 手指1   1523      → 0              │ │
│  │ 手指2   1487      → 0              │ │
│  │ 手指3   1501      → 0              │ │
│  │ ...                                │ │
│  └────────────────────────────────────┘ │
│                                          │
│  [读取当前位置] [下一步] [取消]          │
└─────────────────────────────────────────┘
```

**标定向导对话框（步骤2 - 读取最大位置）：**

```
┌─────────────────────────────────────────┐
│  关节位置标定向导                        │
├─────────────────────────────────────────┤
│  步骤 2/2: 读取最大位置                  │
│                                          │
│  请将机器人移动到最大行程位置            │
│  然后点击"读取当前位置"按钮              │
│                                          │
│  ┌────────────────────────────────────┐ │
│  │ 关节    当前位置   最大位置        │ │
│  │ 手指1   2856      → 2856           │ │
│  │ 手指2   2823      → 2823           │ │
│  │ 手指3   2891      → 2891           │ │
│  │ ...                                │ │
│  └────────────────────────────────────┘ │
│                                          │
│  [读取当前位置] [完成] [上一步] [取消]   │
└─────────────────────────────────────────┘
```

---

## 3. 数据流程设计

### 3.1 读取0位流程

```
用户点击"读取0位"按钮
    ↓
1. 发送状态查询指令到所有关节
   指令类型: 0x72 (状态查询)
    ↓
2. 等待接收所有关节的位置反馈
   超时时间: 1秒
    ↓
3. 解析反馈数据，提取当前位置
   从0x73和0x74帧中提取位置数据
    ↓
4. 显示在标定对话框中
   显示10个关节的当前位置
    ↓
5. 用户确认
    ↓
6. 计算位置偏移量
   offset[i] = current_position[i] - 0
    ↓
7. 保存到配置文件
   calibration:
     zero_offsets: [offset1, offset2, ...]
    ↓
8. 应用到控制系统
   实际发送位置 = 用户设定位置 + offset
```

### 3.2 读取最大位置流程

```
用户点击"读取最大位置"按钮
    ↓
1. 发送状态查询指令到所有关节
    ↓
2. 等待接收所有关节的位置反馈
    ↓
3. 解析反馈数据，提取当前位置
    ↓
4. 显示在标定对话框中
    ↓
5. 用户确认
    ↓
6. 计算最大位置（考虑偏移）
   max_position[i] = current_position[i] - zero_offset[i]
    ↓
7. 保存到配置文件
   joints[i]:
     limits:
       max_position: max_position[i]
    ↓
8. 更新软限位检查
```

---

## 4. 配置文件结构

### 4.1 标定数据存储

在robot_config.yaml中添加标定数据：

```yaml
# 标定数据
calibration:
  # 标定时间戳
  calibrated_at: "2025-12-22 15:30:00"
  
  # 标定方法
  calibration_method: "manual"  # manual, automatic, factory
  
  # 归零位置偏移量（原始硬件位置）
  zero_offsets: [1523, 1487, 1501, 1495, 1512, 1488, 1502, 1497, 1505, 1493]
  
  # 最大位置（相对于0位的行程）
  max_positions: [2700, 2650, 2720, 2680, 2690, 2700, 2650, 2680, 2700, 2660]
  
  # 标定状态
  is_calibrated: true
  
  # 标定备注
  notes: "初次标定，机器人处于完全伸展状态作为0位"

# 关节配置（更新后）
joints:
  - id: 0
    name: "thumb"
    limits:
      # 用户空间的限位（相对于0位）
      min_position: 0
      max_position: 2700  # 从标定数据自动更新
      
      # 硬件空间的限位（原始位置）
      hardware_min: 1523  # zero_offset
      hardware_max: 4223  # zero_offset + max_position
```

### 4.2 标定历史记录

创建独立的标定历史文件：

```yaml
# config/calibration_history.yaml

calibration_records:
  - timestamp: "2025-12-22 15:30:00"
    method: "manual"
    operator: "user"
    zero_offsets: [1523, 1487, ...]
    max_positions: [2700, 2650, ...]
    notes: "初次标定"
    
  - timestamp: "2025-12-23 10:15:00"
    method: "manual"
    operator: "user"
    zero_offsets: [1520, 1485, ...]
    max_positions: [2705, 2655, ...]
    notes: "重新标定，调整了手指1的0位"
```

---

## 5. 核心模块设计

### 5.1 标定管理器 (CalibrationManager)

**职责：**
- 管理标定流程
- 读取和保存标定数据
- 应用标定偏移量

**核心方法：**

```python
class CalibrationManager:
    """标定管理器"""
    
    def __init__(self, hardware_manager, config_manager):
        self.hardware = hardware_manager
        self.config = config_manager
        self.zero_offsets = [0] * 10
        self.max_positions = [3000] * 10
        self.is_calibrated = False
    
    def read_zero_positions(self):
        """读取当前所有关节位置作为0位"""
        # 1. 发送状态查询指令
        # 2. 等待接收反馈
        # 3. 返回位置数组
        pass
    
    def set_zero_offsets(self, positions):
        """设置归零偏移量"""
        # 1. 验证数据
        # 2. 保存偏移量
        # 3. 更新配置文件
        pass
    
    def read_max_positions(self):
        """读取当前所有关节位置作为最大位置"""
        # 1. 发送状态查询指令
        # 2. 等待接收反馈
        # 3. 计算相对于0位的最大行程
        pass
    
    def set_max_positions(self, positions):
        """设置最大位置限制"""
        # 1. 验证数据
        # 2. 保存最大位置
        # 3. 更新软限位配置
        pass
    
    def apply_calibration(self, user_position):
        """将用户空间位置转换为硬件空间位置"""
        # hardware_pos = user_pos + zero_offset
        pass
    
    def reverse_calibration(self, hardware_position):
        """将硬件空间位置转换为用户空间位置"""
        # user_pos = hardware_pos - zero_offset
        pass
    
    def save_calibration(self):
        """保存标定数据到配置文件"""
        pass
    
    def load_calibration(self):
        """从配置文件加载标定数据"""
        pass
    
    def is_calibrated(self):
        """检查系统是否已标定"""
        return self.is_calibrated
```

### 5.2 位置转换流程

**用户空间 ↔ 硬件空间转换：**

```
用户设定位置（0-2700）
    ↓
应用标定偏移
hardware_position = user_position + zero_offset
    ↓
发送到硬件（1523-4223）

硬件反馈位置（1523-4223）
    ↓
移除标定偏移
user_position = hardware_position - zero_offset
    ↓
显示给用户（0-2700）
```

---

## 6. 用户交互流程

### 6.1 标定向导完整流程

```
1. 用户点击"标定向导"按钮
    ↓
2. 系统检查连接状态
   - 如果未连接，提示先连接硬件
    ↓
3. 显示标定向导对话框
    ↓
4. 步骤1：读取0位
   a. 提示用户移动机器人到初始位置
   b. 用户点击"读取当前位置"
   c. 系统查询所有关节位置
   d. 显示读取的位置值
   e. 用户确认或重新读取
   f. 点击"下一步"
    ↓
5. 步骤2：读取最大位置
   a. 提示用户移动机器人到最大行程
   b. 用户点击"读取当前位置"
   c. 系统查询所有关节位置
   d. 计算并显示最大行程
   e. 用户确认或重新读取
   f. 点击"完成"
    ↓
6. 保存标定数据
   a. 写入配置文件
   b. 记录标定历史
   c. 应用到当前系统
    ↓
7. 显示标定成功提示
   a. 显示标定摘要
   b. 提示重启或立即应用
    ↓
8. 关闭向导对话框
```

### 6.2 快速标定流程

**单独读取0位：**
```
1. 点击"读取0位"按钮
2. 系统读取当前位置
3. 弹出确认对话框
4. 用户确认后保存
```

**单独读取最大位置：**
```
1. 点击"读取最大位"按钮
2. 系统读取当前位置
3. 弹出确认对话框
4. 用户确认后保存
```

---

## 7. 安全机制

### 7.1 标定前检查

**标定前必须满足的条件：**

```
标定前检查清单：
├── 硬件连接状态
│   - 必须已连接到机器人
│   - 通信正常
│
├── 控制模式
│   - 必须处于手动模式
│   - 不能在运动过程中标定
│
├── 安全状态
│   - 无急停状态
│   - 无错误报警
│
└── 权限检查
    - 用户具有标定权限
    - 可选：需要管理员密码
```

### 7.2 标定数据验证

**保存前的数据验证：**

```
验证规则：
├── 0位偏移量合理性
│   - 不能为负数
│   - 不能超过硬件最大值
│   - 各关节偏移量不能相差太大（异常检测）
│
├── 最大位置合理性
│   - 必须大于0
│   - 不能超过硬件行程
│   - 最大位置 > 最小位置
│
├── 数据完整性
│   - 所有10个关节都有数据
│   - 没有缺失值
│
└── 逻辑一致性
    - hardware_max = zero_offset + max_position
    - 符合物理约束
```

### 7.3 标定失败处理

**标定失败的处理策略：**

```
标定失败情况：
├── 通信超时
│   → 提示检查连接，重试
│
├── 数据异常
│   → 显示异常数据，要求重新标定
│
├── 验证失败
│   → 显示验证错误，不保存数据
│
└── 用户取消
    → 恢复原有标定数据
```

---

## 8. 开发任务分解

### 8.1 任务列表（按优先级排序）

| 优先级 | 任务 | 预计时间 | 依赖 |
|--------|------|---------|------|
| P0 | 设计CalibrationManager类 | 2小时 | 无 |
| P0 | 实现read_zero_positions() | 1小时 | 串口通信模块 |
| P0 | 实现apply_calibration()转换 | 1小时 | CalibrationManager |
| P0 | 配置文件结构设计 | 1小时 | 无 |
| P1 | UI添加标定按钮 | 1小时 | 主界面 |
| P1 | 实现标定对话框 | 3小时 | UI框架 |
| P1 | 实现read_max_positions() | 1小时 | read_zero_positions |
| P1 | 保存/加载标定数据 | 2小时 | 配置管理器 |
| P2 | 标定向导流程 | 2小时 | 标定对话框 |
| P2 | 数据验证逻辑 | 2小时 | CalibrationManager |
| P2 | 标定历史记录 | 1小时 | 配置管理器 |
| P3 | 标定数据可视化 | 2小时 | 可视化面板 |
| P3 | 标定报告生成 | 1小时 | 数据记录器 |

**总计：** 约20小时（2.5个工作日）

### 8.2 集成到开发路线图

**建议在阶段2（运动控制核心）完成后实施：**

```
阶段2.5：标定功能（第4-5周之间）

目标：实现关节位置标定功能

任务清单：
- [ ] CalibrationManager模块实现
- [ ] 位置转换逻辑实现
- [ ] 标定UI界面实现
- [ ] 配置文件结构更新
- [ ] 标定向导实现
- [ ] 数据验证和安全检查
- [ ] 单元测试

交付物：
- 可用的标定功能
- 标定数据持久化
- 用户友好的标定向导
```

---

## 9. 测试计划

### 9.1 单元测试

**测试用例：**

```
测试CalibrationManager：
├── test_read_zero_positions()
│   - 测试正常读取
│   - 测试通信超时
│   - 测试数据异常
│
├── test_apply_calibration()
│   - 测试正向转换
│   - 测试边界值
│   - 测试负数处理
│
├── test_reverse_calibration()
│   - 测试反向转换
│   - 测试与正向转换的一致性
│
├── test_save_load_calibration()
│   - 测试保存功能
│   - 测试加载功能
│   - 测试数据完整性
│
└── test_validation()
    - 测试数据验证逻辑
    - 测试异常数据拒绝
```

### 9.2 集成测试

**测试场景：**

```
场景1：首次标定
1. 启动系统（未标定状态）
2. 连接硬件
3. 运行标定向导
4. 读取0位
5. 读取最大位置
6. 保存标定数据
7. 验证标定生效

场景2：重新标定
1. 系统已有标定数据
2. 运行标定向导
3. 更新标定数据
4. 验证新标定生效
5. 检查历史记录

场景3：标定数据应用
1. 加载标定数据
2. 发送控制指令
3. 验证位置转换正确
4. 检查软限位生效
```

---

## 10. 实施检查清单

### 开发前准备
- [ ] 确认现有串口通信模块支持位置查询
- [ ] 确认配置管理模块支持动态更新
- [ ] 准备测试用的机器人硬件

### 核心功能实现
- [ ] CalibrationManager类实现
- [ ] 位置转换逻辑实现
- [ ] 配置文件结构更新
- [ ] 标定数据保存/加载

### UI实现
- [ ] 主界面添加标定按钮
- [ ] 标定对话框实现
- [ ] 标定向导实现
- [ ] 状态显示更新

### 测试验证
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 用户验收测试

### 文档更新
- [ ] 更新技术方案文档
- [ ] 编写用户操作手册
- [ ] 更新API文档

---

**文档结束**
