# EvoBot运动学求解器使用指南

## 概述

EvoBot运动学求解器基于Robotics Toolbox for Python实现，提供了完整的运动学计算功能，包括正运动学、逆运动学、雅可比矩阵计算、工作空间分析等。

## 功能特性

### 1. 正运动学求解
- 根据关节角度计算末端执行器位姿
- 支持DH参数建模
- 高性能计算（<1µs）

### 2. 逆运动学求解
- 根据目标位姿计算关节角度
- 使用Levenberg-Marquardt算法
- 支持多解处理和最优解选择

### 3. 雅可比矩阵计算
- 计算6×10雅可比矩阵
- 支持基坐标系和工具坐标系
- 用于速度控制和奇异点分析

### 4. 工作空间分析
- 蒙特卡洛采样分析
- 工作空间边界计算
- 可达性分析

### 5. 奇异点检测
- 基于可操作性指标
- 实时奇异点监控
- 奇异点规避策略

## 安装依赖

```bash
# 安装Robotics Toolbox
pip install roboticstoolbox-python>=1.1.0
pip install spatialmath-python>=1.1.0

# 可选：安装可视化依赖
pip install matplotlib>=3.7.0
```

## 基本使用

### 1. 获取运动学求解器实例

```python
from core.kinematics_solver import get_kinematics_solver, Pose6D

# 获取全局求解器实例
solver = get_kinematics_solver()

# 检查是否可用
if solver.is_enabled():
    print("运动学求解器可用")
else:
    print("运动学求解器不可用，请检查依赖")
```

### 2. 正运动学求解

```python
# 定义关节角度（弧度）
joint_angles = [0.1, 0.2, 0.0, -0.1, 0.3, 0.0, 0.1, -0.2, 0.0, 0.1]

# 正运动学求解
fk_result = solver.forward_kinematics(joint_angles)

if fk_result.success:
    pose = fk_result.end_effector_pose
    print(f"末端执行器位置: ({pose.x:.3f}, {pose.y:.3f}, {pose.z:.3f})")
    print(f"末端执行器姿态: ({pose.roll:.3f}, {pose.pitch:.3f}, {pose.yaw:.3f})")
    print(f"计算时间: {fk_result.computation_time*1000:.1f}ms")
else:
    print(f"正运动学求解失败: {fk_result.error_message}")
```

### 3. 逆运动学求解

```python
# 定义目标位姿
target_pose = Pose6D(
    x=0.3,      # 300mm
    y=0.2,      # 200mm  
    z=0.4,      # 400mm
    roll=0.0,   # 0度
    pitch=0.1,  # 约5.7度
    yaw=0.0     # 0度
)

# 逆运动学求解
ik_result = solver.inverse_kinematics(target_pose)

if ik_result.success:
    print("逆运动学求解成功:")
    for i, angle in enumerate(ik_result.joint_angles):
        print(f"关节{i}: {np.rad2deg(angle):.1f}°")
    print(f"计算时间: {ik_result.computation_time*1000:.1f}ms")
    print(f"迭代次数: {ik_result.iterations}")
else:
    print(f"逆运动学求解失败: {ik_result.error_message}")
```

### 4. 雅可比矩阵计算

```python
# 计算雅可比矩阵
jacobian = solver.jacobian(joint_angles)

if jacobian is not None:
    print(f"雅可比矩阵形状: {jacobian.shape}")
    print("雅可比矩阵:")
    print(jacobian)
else:
    print("雅可比矩阵计算失败")
```

### 5. 可操作性和奇异点检测

```python
# 计算可操作性指标
manipulability = solver.manipulability(joint_angles)
print(f"可操作性指标: {manipulability:.6f}")

# 检测奇异点
is_singular = solver.is_singular(joint_angles, threshold=1e-3)
if is_singular:
    print("警告: 当前配置接近奇异点")
else:
    print("当前配置正常")
```

### 6. 工作空间分析

```python
# 工作空间分析
workspace_data = solver.workspace_analysis(num_samples=1000)

if workspace_data:
    print(f"有效配置数量: {workspace_data['num_valid_configs']}")
    print(f"工作空间边界: {workspace_data['min_bounds']} 到 {workspace_data['max_bounds']}")
    print(f"工作空间体积: {workspace_data['workspace_volume']:.6f} m³")
    print(f"可达性比例: {workspace_data['reachability_ratio']:.1%}")
else:
    print("工作空间分析失败")
```

## 高级功能

### 1. 与运动控制器集成

```python
from core.motion_controller import get_motion_controller

controller = get_motion_controller()

# 笛卡尔空间运动
target_pose = Pose6D(x=0.3, y=0.2, z=0.4)
success = controller.move_to_pose(target_pose)

if success:
    print("开始笛卡尔空间运动")
else:
    print("笛卡尔空间运动失败")

# 获取当前位姿
current_pose = controller.get_current_pose()
if current_pose:
    print(f"当前位姿: {current_pose}")

# 检查当前配置
manipulability = controller.get_manipulability()
is_singular = controller.check_singularity()
print(f"可操作性: {manipulability:.3f}, 奇异点: {is_singular}")
```

### 2. 路径规划集成

```python
from core.advanced_planner import get_advanced_planner, Obstacle, PlanningAlgorithm

planner = get_advanced_planner()

# 添加障碍物
obstacle = Obstacle(
    center=[0.2, 0.2, 0.3],
    size=[0.1, 0.1, 0.1],
    type="box"
)
planner.set_obstacles([obstacle])

# 笛卡尔空间路径规划
start_pose = Pose6D(x=0.1, y=0.1, z=0.3)
goal_pose = Pose6D(x=0.4, y=0.4, z=0.3)

planning_result = planner.plan_cartesian_path(
    start_pose, 
    goal_pose, 
    algorithm=PlanningAlgorithm.RRT
)

if planning_result.success:
    print(f"路径规划成功，路径长度: {len(planning_result.path)}")
    print(f"规划时间: {planning_result.computation_time:.3f}s")
    
    # 路径优化
    optimized_path = planner.optimize_path(planning_result.path)
    print(f"优化后路径长度: {len(optimized_path)}")
    
    # 转换为轨迹
    trajectory = planner.path_to_trajectory(optimized_path, total_duration=5.0)
    if trajectory:
        print("轨迹生成成功")
else:
    print(f"路径规划失败: {planning_result.error_message}")
```

## 配置说明

### 1. 机器人配置

在`config/robot_config.yaml`中配置DH参数：

```yaml
joints:
  - id: 0
    name: "thumb"
    type: "revolute"
    dh_params:
      d: 0.05      # 连杆偏移 (m)
      a: 0.08      # 连杆长度 (m)
      alpha: 1.57  # 连杆扭角 (rad)
      theta: 0.0   # 关节角度偏移 (rad)
    limits:
      min_position: 0
      max_position: 3000
      max_velocity: 800
      max_acceleration: 1500
```

### 2. 求解器参数

```yaml
kinematics:
  solver_config:
    method: "LM"              # Levenberg-Marquardt
    max_iterations: 100       # 最大迭代次数
    tolerance: 1e-6          # 收敛容差
    lambda_min: 1e-12        # 最小阻尼因子
    lambda_max: 1e6          # 最大阻尼因子
  
  singularity_threshold: 1e-3  # 奇异点阈值
  workspace_samples: 1000      # 工作空间采样数
```

## 性能优化

### 1. 计算性能

- 正运动学：< 1µs
- 逆运动学：< 20µs  
- 雅可比矩阵：< 5µs
- 工作空间分析：< 1s (1000采样点)

### 2. 优化建议

1. **缓存计算结果**：对于相同的关节配置，缓存正运动学结果
2. **合理设置初始猜测**：逆运动学求解时提供好的初始猜测
3. **调整求解器参数**：根据精度要求调整迭代次数和容差
4. **并行计算**：工作空间分析可以并行化

## 故障排除

### 1. 常见问题

**Q: 运动学求解器不可用**
A: 检查是否安装了roboticstoolbox-python和spatialmath-python

**Q: 逆运动学求解失败**
A: 检查目标位姿是否在工作空间内，调整求解器参数

**Q: 奇异点警告**
A: 调整关节配置远离奇异点，或使用奇异点规避算法

**Q: 计算速度慢**
A: 检查DH参数设置，优化求解器参数

### 2. 调试技巧

```python
# 启用详细日志
import logging
logging.getLogger('roboticstoolbox').setLevel(logging.DEBUG)

# 检查机器人模型
robot_info = solver.get_robot_info()
print("机器人信息:", robot_info)

# 验证DH参数
for i, dh in enumerate(robot_info['dh_parameters']):
    print(f"关节{i}: {dh}")

# 测试正逆运动学一致性
joint_angles = [0.1] * 10
fk_result = solver.forward_kinematics(joint_angles)
if fk_result.success:
    ik_result = solver.inverse_kinematics(fk_result.end_effector_pose)
    if ik_result.success:
        error = np.linalg.norm(np.array(joint_angles) - np.array(ik_result.joint_angles))
        print(f"正逆运动学误差: {error:.6f}")
```

## 扩展开发

### 1. 自定义机器人模型

```python
class CustomRobot(EvoBot10DOF):
    def __init__(self, config):
        super().__init__(config)
        # 自定义初始化
    
    def _create_robot_model(self):
        # 自定义机器人模型创建
        pass
```

### 2. 自定义求解算法

```python
class CustomKinematicsSolver(KinematicsSolver):
    def inverse_kinematics_custom(self, target_pose, method="custom"):
        # 自定义逆运动学算法
        pass
```

### 3. 性能监控

```python
from utils.logger import log_performance

@log_performance
def custom_kinematics_function():
    # 自动记录性能数据
    pass
```

## 参考资料

1. [Robotics Toolbox for Python文档](https://petercorke.github.io/robotics-toolbox-python/)
2. [Spatial Math文档](https://petercorke.github.io/spatialmath-python/)
3. [DH参数标准](https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters)
4. [逆运动学算法](https://en.wikipedia.org/wiki/Inverse_kinematics)