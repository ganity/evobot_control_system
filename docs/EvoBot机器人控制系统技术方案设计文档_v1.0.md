
  ---
  EvoBot机器人控制系统技术方案设计文档

  版本： v1.0
  日期： 2025-12-22
  方案类型： 方案A - 轻量级Python控制框架
  技术栈： Robotics Toolbox + PythonRobotics + PyQt5

  ---
  目录

  1. #1-项目概述
  2. #2-系统架构设计
  3. #3-模块设计
  4. #4-数据流设计
  5. #5-运动控制策略
  6. #6-配置管理
  7. #7-安全机制
  8. #8-性能指标
  9. #9-开发路线图
  10. #10-技术风险评估

  ---
  1. 项目概述

  1.1 项目目标

  设计并实现一个轻量级、高性能、易于调试的机器人控制系统，用于控制10自由度的EvoBot机器人手臂，实现平滑、精确的运动控制。 这是一个PC端调试程序；

  1.2 核心需求

  功能需求：
  - 支持10个关节的独立和协调控制
  - 实现平滑的轨迹规划和插值
  - 提供多种控制模式（手动、轨迹、示教、脚本）
  - 实时状态监控和数据可视化
  - 参数调优和配置管理
  - 运动序列录制和回放

  非功能需求：
  - Windows平台完美支持
  - 200Hz控制频率
  - 低延迟响应（<10ms）
  - 易于调试和扩展
  - 模块化架构

  1.3 技术选型

  | 组件       | 技术选型                    | 理由                         |
  |------------|-----------------------------|------------------------------|
  | 运动学引擎 | Robotics Toolbox for Python | 专业、高性能、Windows支持好  |
n  | UI框架     | PyQt5                       | 成熟稳定、跨平台、功能强大   |
  | 数值计算   | NumPy + SciPy               | 行业标准、性能优秀           |
  | 数据可视化 | Matplotlib + PyQtGraph      | 实时曲线、高性能             |
  | 配置管理   | YAML                        | 人类可读、易于编辑           |
  | 通信协议   | RS-485串口（现有协议）      | 保持硬件兼容性               |

  2. 系统架构设计

  2.1 整体架构

  系统采用分层架构设计，从上到下分为五层：

  ┌─────────────────────────────────────────────────────────┐
  │                   表示层 (Presentation Layer)            │
  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
  │  │  主控制界面   │  │  参数调优界面 │  │  数据可视化   │  │
  │  │  (PyQt5)     │  │  (PyQtGraph)  │  │
  │  └──────────────┘  └──────────────┘  │
  └─────────────────────────────────────────────────────────┘
                  ↓ 事件/命令
  ┌─────────────────────────────────────────────────────────┐
  │                   应用层 (Application Layer)             │
  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
  │  │  控制模式管理 │  │  序列编辑器   │  │  数据记录器   │  │
  │  │  (手动/轨迹)  │  │  (录制/回放)  │  │  (CSV/日志)   │  │
  │  └──────────────┘  │
  └─────────────────────────────────────────────────────────┘
                            ↓ 运动指令
  ┌─────────────────────────────────────────────────────────┐
  │                   控制层 (Control Layer)                 │
  │  ┌──────────────────────────────────────────────────┐  │
  │  │            运动控制器 (Motion Controller)         │  │
  │  │  ┌────────────┐  ┌────────────┐  ┌────────────┐ │  │
  │  │  │ 轨迹规划器  │  │ 运动学求解器│  │ 插值引擎   │ │  │
  │  │  │ (Planner)  │  │ (Kinematics)│  │ (Interpolator)│ │
  │  │  └────────────┘  └────────────┘  └────────────┘ │  │
  │  └──────────────────────────────────────────────────┘  │
  └─────────────────────────────────────────────────────────┘
                            ↓ 关节指令
  ┌─────────────────────────────────────────────────────────┐
  │                   硬件抽象层 (HAL)                       │
  │  ┌──────────────────────────────────────────────────┐  │
  │  │         硬件接口管理器 (Hardware Manager)         │  │
  │  │  ┌────────────┐  ┌────────────┐  ┌────────────┐ │  │
  │  │  │ 串口管理器  │  │ 协议编解码器│  │ 状态监控器 │ │  │
  │  │  │ (Serial)   │  │ (Protocol) │  │ (Monitor)  │ │  │
  │  │  └────────────┘  └────────────┘  └────────────┘ │  │
  │  └──────────────────────────────────────────────────┘  │
  └─────────────────────────────────────────────────────────┘
                            ↓ RS-485
  ┌─────────────────────────────────────────────────────────┐
  │                   硬件层 (Hardware Layer)                │
  │              EvoBot机器人 (10自由度)│
  │  5个手指 + 1个手腕 + 2个肘部 + 2个肩部                   │
  └─────────────────────────────────────────────────────────┘

  2.2 架构设计原则

  分层解耦：
  - 每层只依赖下层接口，不依赖具体实现
  - 层与层之间通过明确的接口通信
  - 便于单元测试和模块替换

  职责单一：
  - 每个模块只负责一个明确的功能
  - 避免功能交叉和耦合
  - 提高代码可维护性

  可扩展性：
  - 支持插件式扩展（新的控制模式、新的轨迹算法）
  - 配置驱动，减少硬编码
  - 预留接口用于未来功能扩展

  高性能：
  - 关键路径优化（控制循环）
  - 异步处理非关键任务（UI更新、日志记录）
  - 内存池和对象复用

  ---
  3. 模块设计

  3.1 表示层模块

  3.1.1 主控制界面 (MainWindow)

  职责：
  - 提供用户交互入口
  - 显示机器人实时状态
  - 接收用户控制指令

  核心功能：
  - 关节控制面板（滑块/数值输入）
  - 控制模式切换（手动/轨迹/示教/脚本）
  - 急停按钮和安全控制
  - 连接管理（串口连接/断开）
  - 状态指示器（连接状态、运行状态、错误提示）

  界面布局：
  ┌─────────────────────────────────────────────────────┐
  │  [菜单栏] 文件 | 编辑 | 控制 | 工具 | 帮助           │
  ├─────────────────────────────────────────────────────┤
  │  [工具栏] [连接] [断开] [急停] [复位] [录制] [回放] │
  ├──────────────────┬──────────────────────────────────┤
  │  关节控制面板     │   状态监控面板                    │
  │  ┌────────────┐  │   ┌──────────────────────────┐  │
  │  │ 手指1 [滑块]│  │   │ 位置: [100, 200, ...]    │  │
  │  │ 手指2 [滑块]│  │   │ 速度: [10, 20, ...]      │  │
  │  │ 手指3 [滑块]│  │   │ 电流: [50, 60, ...]      │  │
  │  │ 手指4 [滑块]│  │   │ 温度: [25, 26, ...]      │  │
  │  │ 手指5 [滑块]│  │   │ 错误: 无                  │  │
  │  │ 手腕  [滑块]│  │   └──────────────────────────┘  │
  │  │ 肘部1 [滑块]│  │                │
  │  │ 肘部2 [滑块]│  │   实时曲线显示                    │
  │  │ 肩部1 [滑块]│  │   ┌──────────────────────────┐  │
  │  │ 肩部2 [滑块]│  │   │  [位置曲线]│  │
  │  └────────────┘  │   │  [速度曲线]               │  │
  │                   │   │  [电流曲线]               │  │
  │  控制模式选择     │   └──────────────────────────┘  │
  │  ○ 手动模式       │                                  │
  │  ○ 轨迹模式       │                                  │
  │  ○ 示教模式       │                                  │
  │  ○ 脚本模式       │                                  │
  └──────────────────┴──────────────────────────────────┘
  │  [状态栏] 连接状态: 已连接 | 控制频率: 200Hz | ...   │
  └─────────────────────────────────────────────────────┘

  1. "读取0位"功能 - 从串口读取各电机当前位置作为归零位置
  2. "最大位置读取"功能 - 读取各电机的最大位置

  3.1.2 参数调优界面 (ParameterTuningWindow)

  职责：
  - 提供运动参数的实时调整
  - 可视化参数对运动效果的影响
  - 保存和加载参数配置

  核心功能：
  - 轨迹参数调整（速度、加速度、插值方法）
  - 控制参数调整（PID参数、前馈增益）
  - 安全限制设置（位置限位、速度限制、电流限制）
  - 参数预设管理（保存/加载/导入/导出）
  - 实时效果预览

  3.1.3 数据可视化面板 (VisualizationPanel)

  职责：
  - 实时显示机器人运动数据
  - 提供多种图表类型
  - 支持数据导出和分析

  核心功能：
  - 实时曲线图（位置、速度、加速度、电流）
  - 多关节对比显示
  - 时间轴缩放和平移
  - 数据标记和注释
  - 截图和数据导出

  ---
  3.2 应用层模块

  3.2.1 控制模式管理器 (ControlModeManager)

  职责：
  - 管理不同控制模式的切换
  - 协调各控制模式的生命周期
  - 确保模式切换的安全性

  支持的控制模式：

  1. 手动模式 (Manual Mode)
  - 用户通过滑块直接控制关节位置
  - 实时生成平滑轨迹
  - 适合单关节调试和简单操作

  2. 轨迹模式 (Trajectory Mode)
  - 用户指定起点和终点
  - 系统自动生成平滑轨迹
  - 支持多种插值算法选择
  - 适合精确的点到点运动

  3. 示教模式 (Teaching Mode)
  - 用户拖动机器人到目标位置
  - 系统记录关键帧
  - 可回放录制的运动序列
  - 适合复杂运动序列的快速编程

  4. 脚本模式 (Script Mode)
  - 用户编写Python脚本控制机器人
  - 支持循环、条件判断、函数调用
  - 提供丰富的API接口
  - 适合自动化测试和批量操作

  模式切换状态机：
          [初始化]↓
        [空闲状态]
        ↙  ↓  ↘  ↘
    手动  轨迹 示教 脚本
      ↘  ↓  ↙  ↙
        [运行中]
             ↓
        [暂停/停止]
             ↓
        [空闲状态]

  3.2.2 运动序列编辑器 (SequenceEditor)

  职责：
  - 创建和编辑运动序列
  - 管理关键帧和时间轴
  - 提供序列的保存和加载

  核心功能：
  - 关键帧管理（添加、删除、修改、复制）
  - 时间轴编辑（调整时间、插入延迟）
  - 序列预览和仿真
  - 序列优化（平滑过渡、时间优化）
  - 序列库管理（保存常用序列）

  序列数据结构：
  运动序列 (Sequence)
  ├── 序列名称
  ├── 序列描述
  ├── 创建时间
  ├── 关键帧列表
  │   ├── 关键帧1
  │   │   ├── 时间戳
  │   │   ├── 关节位置 [10个值]
  │   │   ├── 运动参数（速度、加速度）
  │   │   └── 插值方法
  │   ├── 关键帧2
  │   └── ...
  └── 元数据（作者、版本等）

  3.2.3 数据记录器 (DataLogger)

  职责：
  - 记录机器人运行数据
  - 提供多种记录格式
  - 支持数据回放和分析

  核心功能：
  - 实时数据记录（位置、速度、电流、温度）
  - 事件记录（用户操作、系统事件、错误）
  - 多种输出格式（CSV、JSON、HDF5）
  - 数据压缩和归档
  - 数据回放和可视化

  记录策略：
  - 连续记录模式（记录所有数据）
  - 触发记录模式（满足条件时记录）
  - 环形缓冲模式（保留最近N秒数据）
  - 事件驱动模式（仅记录关键事件）


  3.3 控制层模块

  3.3.1 运动控制器 (MotionController)

  职责：
  - 协调轨迹规划、运动学求解和插值引擎
  - 管理控制循环的执行
  - 提供统一的运动控制接口

  核心组件：

  A. 轨迹规划器 (TrajectoryPlanner)

  职责：
  - 根据起点和终点生成平滑轨迹
  - 应用速度和加速度约束
  - 支持多种插值算法

  支持的插值算法：

  | 算法名称     | 特点               | 适用场景           | 连续性             |
  |--------------|--------------------|--------------------|--------------------|
  | 线性插值     | 最简单，计算快     | 低速运动、简单路径 | C0（位置连续）     |
  | 三次样条     | 速度连续，平滑     | 一般运动场景       | C1（速度连续）     |
  | 五次多项式   | 加速度连续，最平滑 | 高精度运动         | C2（加速度连续）   |
  | 梯形速度曲线 | 明确加减速阶段     | 点到点运动         | C0（分段连续）     |
  | S曲线        | 加加速度连续       | 高速运动、减少冲击 | C3（加加速度连续） |
  | Bezier曲线   | 灵活控制路径形状   | 复杂路径           | C1                 |

  轨迹生成流程：
  输入：起点位置、终点位置、运动时间、约束条件
    ↓
  1. 计算路径长度和方向
    ↓
  2. 选择插值算法
    ↓
  3. 生成初始轨迹点
    ↓
  4. 应用速度约束（限制最大速度）
    ↓
  5. 应用加速度约束（限制最大加速度）
    ↓
  6. 平滑处理（消除突变）
    ↓
  7. 重采样到控制频率（200Hz）
    ↓
  输出：轨迹点序列 [时间, 位置, 速度, 加速度]

  B. 运动学求解器 (KinematicsSolver)

  职责：
  - 提供正运动学和逆运动学求解
  - 支持关节空间和笛卡尔空间的转换
  - 处理运动学奇异点

  核心功能：

  正运动学 (Forward Kinematics):
  - 输入：关节角度 [θ1, θ2, ..., θ10]
  - 输出：末端执行器位姿 [x, y, z, roll, pitch, yaw]
  - 算法：DH参数法或变换矩阵法
  - 性能要求：<1µs

  逆运动学 (Inverse Kinematics):
  - 输入：末端执行器目标位姿
  - 输出：关节角度解 [θ1, θ2, ..., θ10]
  - 算法：数值迭代法（Levenberg-Marquardt）
  - 性能要求：<20µs
  - 处理多解情况（选择最优解）

  机器人模型定义：
  机器人模型 (Robot Model)
  ├── 关节定义
  │   ├── 关节1: 拇指（旋转关节）
  │   │   ├── DH参数 (d, a, α, θ)
  │   │   ├── 关节限位 [min, max]
  │   │   └── 关节类型（旋转/平移）
  │   ├── 关节2: 食指
  │   ├── ...
  │   └── 关节10: 肩部2
  ├── 连杆参数
  │   ├── 长度、质量、惯性
  │   └── 坐标系定义
  └── 末端执行器
      ├── 工具坐标系
      └── 负载参数

  C. 插值引擎 (InterpolationEngine)

  职责：
  - 实时插值生成控制点
  - 管理轨迹缓冲队列
  - 处理轨迹的实时修改

  核心功能：
  - 轨迹点缓冲（预加载N个点）
  - 实时插值计算
  - 轨迹平滑过渡（新旧轨迹融合）
  - 轨迹中断和恢复

  插值策略：
  轨迹缓冲队列 (FIFO)
  ┌────────────────────────────────┐
  │ [点1] [点2] [点3] ... [点N]    │  预加载缓冲区
  └────────────────────────────────┘↓ 每5ms取一个点
    [当前点] → 发送到硬件
       ↓
    [已发送] → 丢弃

  缓冲区管理：
  - 缓冲区大小：200个点（1秒）
  - 低水位警告：<50个点
  - 高水位限制：>500个点
  - 缓冲区耗尽处理：保持当前位置

  ---
  3.3.2 控制循环设计

  控制循环架构：
  主控制循环 (200Hz, 5ms周期)
  ┌─────────────────────────────────┐
  │  1. 读取硬件状态                 │
  │     - 关节位置                   │
  │     - 关节速度                   │
  │     - 电流反馈                   │
  │     - 错误状态                   │
  ├─────────────────────────────────┤
  │  2. 状态更新                     │
  │     - 更新机器人状态             │
  │     - 检测异常情况               │
  │     - 触发安全检查               │
  ├─────────────────────────────────┤
  │  3. 轨迹生成                     │
  │     - 从缓冲区取下一个点         │
  │     - 或根据模式生成新点         │
  │     - 应用平滑过渡               │
  ├─────────────────────────────────┤
  │  4. 控制计算                     │
  │     - 位置控制                   │
  │     - 速度前馈（可选）           │
  │     - PID闭环（可选）            │
  ├─────────────────────────────────┤
  │  5. 安全检查                     │
  │     - 位置限位检查               │
  │     - 速度限制检查               │
  │     - 电流限制检查               │
  │     - 碰撞检测（可选）           │
  ├─────────────────────────────────┤
  │  6. 发送指令                     │
  │     - 编码控制指令               │
  │     - 发送到硬件                 │
  │     - 记录发送日志               │
  ├─────────────────────────────────┤
  │  7. 数据记录（异步）             │
  │     - 记录状态数据               │
  │     - 更新可视化                 │
  └─────────────────────────────────┘

  时序保证：
  - 使用高精度定时器（QTimer或threading.Timer）
  - 监控循环执行时间
  - 超时告警（>5ms）
  - 统计循环抖动

  ---
  3.4 硬件抽象层模块

  3.4.1 硬件接口管理器 (HardwareManager)

  职责：
  - 管理与机器人硬件的通信
  - 提供统一的硬件访问接口
  - 处理硬件异常和重连

  核心组件：

  A. 串口管理器 (SerialManager)

  职责：
  - 管理RS-485串口连接
  - 处理串口的打开、关闭、重连
  - 监控串口状态

  核心功能：
  - 串口扫描和自动识别
  - 连接管理（连接、断开、重连）
  - 缓冲区管理（发送缓冲、接收缓冲）
  - 错误处理（超时、断线、校验错误）
  - 连接状态监控

  串口配置：
  串口参数
  ├── 端口号: COM3 (Windows) / /dev/ttyUSB0 (Linux)
  ├── 波特率: 1000000 bps
  ├── 数据位: 8
  ├── 停止位: 1
  ├── 校验位: None
  ├── 流控制: None
  ├── 超时设置: 100ms
  └── 缓冲区大小: 12000 bytes

  B. 协议编解码器 (ProtocolCodec)

  职责：
  - 实现RS-485通信协议
  - 编码控制指令
  - 解码反馈数据

  协议格式（基于现有协议）：

  发送帧格式：
  ┌────┬────┬────┬────────┬────┬────┐
  │帧头│长度│类型│ 数据   │校验│帧尾│
  │0xFD│ N  │0xXX│ ...    │CRC │0xF8│
  └────┴────┴────┴────────┴────┴────┘

  接收帧格式：
  ┌────┬────┬────┬────┬────────┬────┬────┐
  │帧头│长度│序号│类型│ 数据   │校验│帧尾│
  │0xFD│ N  │SEQ │0xXX│ ...    │CRC │0xF8│
  └────┴────┴────┴────┴────────┴────┴────┘

  帧类型定义：
  | 帧类型       | 代码 | 方向 | 说明                 |
  |--------------|------|------|----------------------|
  | 位置控制指令 | 0x71 | 发送 | 设置10个关节目标位置 |
  | 状态查询指令 | 0x72 | 发送 | 查询关节状态         |
  | 手指状态反馈 | 0x74 | 接收 | 5个手指+手腕状态     |
  | 手臂状态反馈 | 0x73 | 接收 | 肩部+肘部状态        |
  | ID配置指令   | 0x75 | 发送 | 配置电机ID           |
  | 错误报告     | 0x7F | 接收 | 硬件错误信息         |

  转义机制：
  - 特殊字符：0xFD, 0xFE, 0xF8
  - 转义规则：0xFE + (原字符 & 0x0F + 0x70)
  - 解转义：检测0xFE，还原原始字符

  C. 状态监控器 (StatusMonitor)

  职责：
  - 监控机器人实时状态
  - 检测异常情况
  - 触发告警和保护

  监控项目：
  状态监控
  ├── 通信状态
  │   ├── 连接状态（已连接/断开）
  │   ├── 通信延迟（<10ms正常）
  │   ├── 丢包率（<1%正常）
  │   └── 校验错误率
  ├── 关节状态
  │   ├── 位置（是否在限位内）
  │   ├── 速度（是否超速）
  │   ├── 电流（是否过流）
  │   └── 温度（是否过热）
  ├── 系统状态
  │   ├── 控制频率（200Hz±5%）
  │   ├── CPU使用率（<50%）
  │   ├── 内存使用（<500MB）
  │   └── 磁盘空间（>1GB）
  └── 错误状态
      ├── 硬件错误
      ├── 通信错误
      ├── 控制错误
      └── 系统错误

  告警级别：
  - 信息 (Info): 正常事件，仅记录
  - 警告 (Warning): 潜在问题，需要关注
  - 错误 (Error): 功能异常，需要处理
  - 严重 (Critical): 安全问题，立即停止


  ---
  4. 数据流设计

  4.1 控制数据流

  从用户输入到硬件执行的完整数据流：

  用户操作（滑块/按钮）
      ↓
  [UI事件] → 事件队列
      ↓
  控制模式管理器
      ↓ 根据当前模式处理
  ┌───────────────────────────────────────┐
  │ 手动模式：直接生成目标位置             │
  │ 轨迹模式：调用轨迹规划器               │
  │ 示教模式：记录当前位置                 │
  │ 脚本模式：执行脚本指令                 │
  └───────────────────────────────────────┘
      ↓
  运动控制器
      ↓
  轨迹规划器 → 生成轨迹点序列
      ↓
  插值引擎 → 轨迹缓冲队列
      ↓
  控制循环（200Hz）→ 每5ms取一个点
      ↓
  运动学求解器（可选）→ 关节空间/笛卡尔空间转换
      ↓
  安全检查 → 限位/速度/电流检查
      ↓
  协议编码器 → 编码为RS-485帧
      ↓
  串口管理器 → 发送到硬件
      ↓
  机器人执行

  4.2 反馈数据流

  从硬件反馈到UI显示的完整数据流：

  机器人硬件 → 发送状态数据
      ↓
  串口管理器 → 接收RS-485帧
      ↓
  协议解码器 → 解析帧数据
      ↓
  状态监控器 → 更新机器人状态
      ↓
  ┌───────────────────────────────────────┐
  │ 分发到多个订阅者：                     │
  │ ├─ 控制循环（用于闭环控制）            │
  │ ├─ 数据记录器（记录历史数据）          │
  │ ├─ 可视化面板（更新曲线图）            │
  │ └─ 状态显示（更新UI）                  │
  └───────────────────────────────────────┘
      ↓
  UI更新（50Hz，降频显示）

  4.3 数据结构定义

  4.3.1 机器人状态数据结构

  RobotState (机器人状态)
  ├── timestamp: 时间戳（毫秒）
  ├── joint_states: 关节状态数组 [10]
  │   ├── joint_id: 关节ID (0-9)
  │   ├── position: 位置（度或毫米）
  │   ├── velocity: 速度（度/秒或毫米/秒）
  │   ├── current: 电流（毫安）
  │   ├── temperature: 温度（摄氏度）
  │   └── error_code: 错误代码
  ├── system_status: 系统状态
  │   ├── connection_status: 连接状态
  │   ├── control_mode: 当前控制模式
  │   ├── emergency_stop: 急停状态
  │   └── error_flags: 错误标志位
  └── power_status: 电源状态
      ├── wrist_board_current: 手腕板总电流
      ├── shoulder_board_current: 手臂板总电流
      └── voltage: 电压

  4.3.2 控制指令数据结构

  ControlCommand (控制指令)
  ├── timestamp: 时间戳
  ├── command_type: 指令类型
  │   ├── POSITION_CONTROL: 位置控制
  │   ├── VELOCITY_CONTROL: 速度控制
  │   ├── CURRENT_CONTROL: 电流控制
  │   └── MIXED_CONTROL: 混合控制
  ├── target_positions: 目标位置数组 [10]
  ├── target_velocities: 目标速度数组 [10]（可选）
  ├── control_gains: 控制增益（可选）
  │   ├── kp: 比例增益
  │   ├── ki: 积分增益
  │   └── kd: 微分增益
  └── flags: 控制标志
      ├── enable_feedforward: 启用前馈
      ├── enable_pid: 启用PID
      └── smooth_transition: 平滑过渡

  4.3.3 轨迹点数据结构

  TrajectoryPoint (轨迹点)
  ├── timestamp: 时间戳
  ├── positions: 位置数组 [10]
  ├── velocities: 速度数组 [10]
  ├── accelerations: 加速度数组 [10]
  └── metadata: 元数据
      ├── trajectory_id: 轨迹ID
      ├── point_index: 点索引
      └── interpolation_method: 插值方法

  4.4 消息传递机制

  采用发布-订阅模式（Pub-Sub）：

  消息总线 (MessageBus)
  ├── 主题 (Topics)
  │   ├── robot/state: 机器人状态更新
  │   ├── robot/command: 控制指令
  │   ├── robot/error: 错误事件
  │   ├── trajectory/update: 轨迹更新
  │   ├── ui/event: UI事件
  │   └── system/log: 系统日志
  ├── 发布者 (Publishers)
  │   ├── HardwareManager → robot/state
  │   ├── MotionController → robot/command
  │   ├── StatusMonitor → robot/error
  │   └── MainWindow → ui/event
  └── 订阅者 (Subscribers)
      ├── VisualizationPanel ← robot/state
      ├── DataLogger ← robot/state, robot/command
      ├── StatusMonitor ← robot/state
      └── MotionController ← ui/event

  消息队列管理：
  - 使用线程安全的队列（Queue.Queue）
  - 支持优先级（紧急消息优先处理）
  - 消息过期机制（超时丢弃）
  - 队列满处理策略（丢弃旧消息或阻塞）

  ---
  5. 运动控制策略

  5.1 轨迹规划策略

  5.1.1 点到点运动规划

  场景： 从当前位置移动到目标位置

  规划步骤：

  1. 路径计算
    - 计算每个关节的位移量
    - 确定主导关节（位移最大的关节）
    - 计算运动时间（基于速度限制）
  2. 速度规划
    - 选择速度曲线类型（梯形/S曲线）
    - 计算加速时间、匀速时间、减速时间
    - 确保不超过最大速度和加速度
  3. 轨迹生成
    - 根据速度曲线生成时间序列
    - 对每个关节进行插值
    - 生成轨迹点序列
  4. 同步控制
    - 所有关节同时到达目标
    - 调整各关节速度曲线
    - 保持运动协调性

  梯形速度曲线规划：
  速度
   ↑
   │    ┌────────┐  匀速段
   │   ╱│        │╲
   │  ╱ │        │ ╲
   │ ╱  │        │  ╲
   │╱   │        │   ╲
   └────┴────────┴────┴──→ 时间
    加速段  匀速段  减速段

  参数：
  - v_max: 最大速度
  - a_max: 最大加速度
  - t_acc: 加速时间 = v_max / a_max
  - t_dec: 减速时间 = v_max / a_max
  - t_const: 匀速时间（根据总位移计算）

  S曲线速度规划：
  速度
   ↑
   │      ╭────╮  匀速段
   │    ╱│    │╲
   │   ╱ │    │ ╲
   │  ╱  │    │  ╲
   │ ╱   │    │   ╲
   │╱    │    │    ╲
   └─────┴────┴─────┴──→ 时间
    加速段 匀速 减速段

  特点：
  - 加加速度连续
  - 减少机械冲击
  - 更平滑的运动

  5.1.2 多点路径规划

  场景： 经过多个中间点到达目标

  规划策略：

  方法1：分段规划
  - 将路径分解为多个点到点运动
  - 每段独立规划
  - 在连接点处进行速度匹配

  方法2：全局样条插值
  - 使用三次样条或Bezier曲线
  - 一次性生成整条路径
  - 保证全程速度连续

  方法3：时间最优规划
  - 考虑所有约束条件
  - 计算最短时间路径
  - 使用动态规划或优化算法

  5.1.3 实时轨迹修改

  场景： 运动过程中改变目标

  策略：

  平滑过渡：
  原轨迹：A → B
  新轨迹：当前位置C → D

  处理方式：
  1. 计算当前位置C和速度v_c
  2. 生成新轨迹C → D，起始速度为v_c
  3. 使用混合函数平滑过渡- 前N个点：原轨迹 × (1-α) + 新轨迹 × α
     - α从0线性增加到1
  4. 替换轨迹缓冲区

  紧急停止：
  1. 检测到急停信号
  2. 计算当前速度
  3. 生成减速轨迹（最大减速度）
  4. 清空轨迹缓冲区
  5. 执行减速到停止

  5.2 控制算法

  5.2.1 位置控制

  开环位置控制：
  - 直接发送目标位置到硬件
  - 依赖硬件内部控制器
  - 简单高效，适合大多数场景

  闭环位置控制（可选）：
  PID控制器
  ├── 输入：目标位置 - 当前位置 = 位置误差
  ├── 比例项：Kp × 误差
  ├── 积分项：Ki × ∫误差dt
  ├── 微分项：Kd × d(误差)/dt
  └── 输出：控制量（速度或电流）

  参数调优：
  - Kp: 响应速度（过大会振荡）
  - Ki: 消除稳态误差（过大会超调）
  - Kd: 阻尼作用（过大会放大噪声）

  5.2.2 速度前馈控制

  原理：
  - 根据目标速度直接计算控制量
  - 减少位置误差和延迟
  - 提高跟踪性能

  实现：
  控制量 = 位置控制输出 + 速度前馈

  速度前馈 = Kv × 目标速度

  其中：
  - Kv: 速度前馈增益（需要标定）
  - 目标速度：从轨迹规划器获取

  5.2.3 重力补偿（可选）

  场景： 手臂需要克服重力

  方法：
  - 计算各关节的重力力矩
  - 添加到控制输出
  - 减少位置下垂

  计算：
  重力力矩 = 质量 × 重力加速度 × 力臂

  需要参数：
  - 各连杆质量
  - 质心位置
  - 当前关节角度

  5.3 安全控制策略

  5.3.1 限位保护

  软限位：
  每个关节定义：
  ├── min_position: 最小位置
  ├── max_position: 最大位置
  ├── warning_margin: 警告余量（接近限位时警告）
  └── emergency_margin: 紧急余量（强制停止）

  检查逻辑：
  if position < min_position + emergency_margin:
      触发紧急停止
  elif position < min_position + warning_margin:
      发出警告，降低速度

  硬限位：
  - 依赖硬件限位开关
  - 触发后立即停止
  - 需要手动复位

  5.3.2 速度限制

  最大速度限制：
  每个关节定义：
  ├── max_velocity: 最大速度
  ├── max_acceleration: 最大加速度
  └── max_jerk: 最大加加速度（可选）

  检查逻辑：
  if abs(velocity) > max_velocity:
      限制速度到max_velocity
      记录警告日志

  动态速度调整：
  - 根据负载调整最大速度
  - 根据温度降低速度
  - 根据电流限制速度

  5.3.3 电流保护

  过流保护：
  每个关节定义：
  ├── rated_current: 额定电流
  ├── peak_current: 峰值电流（短时允许）
  ├── continuous_time: 峰值电流持续时间限制
  └── overload_threshold: 过载阈值

  保护策略：
  - 电流 > peak_current: 立即停止
  - 电流 > rated_current 持续 > continuous_time: 降低速度
  - 累计过载时间 > 阈值: 强制冷却

  5.3.4 碰撞检测（可选）

  基于电流的碰撞检测：
  检测逻辑：
  1. 建立电流基线模型（正常运动时的电流）
  2. 实时监测电流偏差
  3. 偏差 > 阈值 → 可能碰撞
  4. 立即停止并报警

  参数：
  - 电流阈值：根据经验设定
  - 检测窗口：连续N个周期超阈值
  - 响应时间：<50ms

  ---

⏺ [MODE: INNOVATE]

  继续完成技术方案设计文档的最后部分。

  ---
  6. 配置管理

  6.1 配置文件结构

  采用YAML格式，分层组织配置：

  # config/robot_config.yaml - 机器人配置文件

  # 机器人基本信息
  robot:
    name: "EvoBot"
    version: "1.0"
    dof: 10  # 自由度
    description: "10自由度机器人手臂"

  # 关节配置
  joints:
    # 手指关节
    - id: 0
      name: "thumb"
      type: "revolute"
      # DH参数（用于运动学）
      dh_params:
        d: 0.05      # 连杆偏移
        a: 0.08      # 连杆长度
        alpha: 1.57  # 连杆扭角（弧度）
        theta: 0.0   # 关节角度偏移
      # 限位
      limits:
        min_position: 0
        max_position: 3000
        max_velocity: 800
        max_acceleration: 1500
        max_current: 1000  # 毫安
        max_temperature: 70  # 摄氏度
      # 控制参数
      control:
        kp: 1.0
        ki: 0.0
        kd: 0.1
        feedforward_gain: 0.8# 安全参数
      safety:
        warning_margin: 100
        emergency_margin: 50
        overload_threshold: 5.0  # 秒

    - id: 1
      name: "index_finger"
      # ... 类似配置

    # ... 其他8个关节

  # 通信配置
  communication:
    serial:
      port: "COM3"  # Windows
      # port: "/dev/ttyUSB0"  # Linux
      baudrate: 1000000
      bytesize: 8
      parity: "N"
      stopbits: 1
      timeout: 0.1
      buffer_size: 12000protocol:
      frame_header: 0xFD
      frame_tail: 0xF8
      escape_char: 0xFE
      max_retry: 3
      retry_delay: 0.05  # 秒

  # 控制配置
  control:
    frequency: 200  # Hz
    trajectory_buffer_size: 200  # 点数
    buffer_low_watermark: 50
    buffer_high_watermark: 500
    default_interpolation: "cubic_spline"  # linear, cubic_spline, quintic, trapezoidal, s_curve
    enable_feedforward: true
    enable_pid: false

  # 轨迹规划配置
  trajectory:
    default_duration: 1.0  # 秒
    default_max_velocity: 500
    default_max_acceleration: 1000
    default_max_jerk: 5000
    smooth_factor: 0.1  # 平滑系数

  # 安全配置
  safety:
    enable_soft_limits: true
    enable_velocity_limits: true
    enable_current_limits: true
    enable_collision_detection: false
    emergency_stop_deceleration: 2000  # 最大减速度

  # 数据记录配置
  logging:
    enable: true
    level: "INFO"  # DEBUG, INFO, WARNING, ERROR, CRITICAL
    log_file: "logs/robot.log"
    max_file_size: 10485760  # 10MB
    backup_count: 5
    data_recording:
      enable: false
      format: "csv"  # csv, json, hdf5
      output_dir: "data/"
      record_frequency: 50  # Hz（降采样）

  # UI配置
  ui:
    theme: "light"  # light, dark
    language: "zh_CN"  # zh_CN, en_US
    update_frequency: 50  # Hz
    plot_history_length: 300  # 显示最近300个点
    enable_3d_visualization: false

  6.2 参数预设管理

  预设配置文件：

  # config/presets/high_speed.yaml - 高速模式预设
  name: "高速模式"
  description: "适合快速运动，牺牲平滑度"
  parameters:
    trajectory:
      default_max_velocity: 1000
      default_max_acceleration: 2000
      interpolation: "trapezoidal"
    control:
      enable_feedforward: true
      enable_pid: false

  # config/presets/smooth.yaml - 平滑模式预设
  name: "平滑模式"
  description: "最平滑的运动，速度较慢"
  parameters:
    trajectory:
      default_max_velocity: 300
      default_max_acceleration: 500
      interpolation: "quintic"
      smooth_factor: 0.3
    control:
      enable_feedforward: true
      enable_pid: true

  # config/presets/precision.yaml - 精确模式预设
  name: "精确模式"
  description: "高精度定位，启用闭环控制"
  parameters:
    trajectory:
      default_max_velocity: 200
      default_max_acceleration: 400
      interpolation: "cubic_spline"
    control:
      enable_feedforward: true
      enable_pid: truejoints:
      control:
        kp: 2.0
        ki: 0.5
        kd: 0.2

  6.3 配置加载和验证

  配置加载流程：

  启动时：
  1. 加载默认配置（robot_config.yaml）
  2. 验证配置完整性和合法性
  3. 应用用户自定义配置（覆盖默认值）
  4. 加载预设配置（如果指定）
  5. 最终验证
  6. 初始化系统

  运行时：
  1. 用户修改参数
  2. 验证参数合法性
  3. 热更新（无需重启）
  4. 保存到用户配置文件

  配置验证规则：

  验证项：
  ├── 类型检查（整数、浮点、字符串、布尔）
  ├── 范围检查（最小值、最大值）
  ├── 依赖检查（某些参数依赖其他参数）
  ├── 一致性检查（参数之间的逻辑关系）
  └── 硬件兼容性检查（参数是否超出硬件能力）

  示例：
  - max_velocity 必须 > 0
  - max_acceleration 必须 > 0
  - buffer_size 必须 >= buffer_low_watermark
  - control_frequency 必须在 [10, 1000] 范围内
  - 如果 enable_pid = true，则 kp, ki, kd 必须设置

  ---
  7. 安全机制

  7.1 多层安全架构

  ┌─────────────────────────────────────────┐
  │  第1层：硬件安全                         │
  │  - 硬限位开关                            │
  │  - 过流保护电路                          │
  │  - 急停按钮（硬件）                      │
  └─────────────────────────────────────────┘
                ↑
  ┌─────────────────────────────────────────┐
  │  第2层：固件安全                         │
  │  - 电机驱动器内部保护                    │
  │  - 通信超时保护                          │
  │  - 看门狗定时器                          │
  └─────────────────────────────────────────┘
                ↑
  ┌─────────────────────────────────────────┐
  │  第3层：软件安全（本系统）               │
  │  - 软限位检查                            │
  │  - 速度/加速度限制                       │
  │  - 电流监控                              │
  │  - 碰撞检测                              │
  │  - 轨迹合法性检查                        │
  └─────────────────────────────────────────┘
                ↑
  ┌─────────────────────────────────────────┐
  │  第4层：用户安全                         │
  │  - 急停按钮（软件）                      │
  │  - 操作确认机制                          │
  │  - 安全区域设置                          │
  │  - 权限管理                              │
  └─────────────────────────────────────────┘

  7.2 错误处理机制

  7.2.1 错误分类

  错误级别：

  | 级别 | 名称 | 处理策略           | 示例                 |
  |------|------|--------------------|----------------------|
  | 1    | 信息 | 记录日志           | 连接成功、参数更新   |
  | 2    | 警告 | 记录+提示          | 接近限位、温度偏高   |
  | 3    | 错误 | 记录+降级运行      | 通信丢包、传感器异常 |
  | 4    | 严重 | 记录+停止运动      | 超限位、过流         |
  | 5    | 致命 | 记录+紧急停止+退出 | 硬件故障、系统崩溃   |

  错误类型：

  错误分类树：
  ├── 通信错误
  │   ├── 连接失败
  │   ├── 超时
  │   ├── 校验错误
  │   └── 协议错误
  ├── 硬件错误
  │   ├── 电机故障
  │   ├── 传感器故障
  │   ├── 电源异常
  │   └── 过热
  ├── 控制错误
  │   ├── 超限位
  │   ├── 超速
  │   ├── 过流
  │   ├── 轨迹错误
  │   └── 运动学奇异
  ├── 系统错误
  │   ├── 内存不足
  │   ├── 文件错误
  │   ├── 配置错误
  │   └── 未知异常
  └── 用户错误
      ├── 非法输入
      ├── 权限不足
      └── 操作冲突

  7.2.2 错误处理流程

  错误发生
      ↓
  错误检测和分类
      ↓
  ┌─────────────────────────────────┐
  │ 根据错误级别选择处理策略：       │
  │                                  │
  │ 信息/警告：│
  │   → 记录日志                     │
  │   → 显示提示                     │
  │   → 继续运行                     │
  │                                  │
  │ 错误：                           │
  │   → 记录日志                     │
  │   → 尝试恢复                     │
  │   → 降级运行或继续               │
  │                                  │
  │ 严重：                           │
  │   → 记录日志                     │
  │   → 停止运动                     │
  │   → 进入安全状态                 │
  │   → 等待用户处理                 │
  │                                  │
  │ 致命：                           │
  │   → 记录日志                     │
  │   → 紧急停止                     │
  │   → 保存现场数据                 │
  │   → 安全退出                     │
  └─────────────────────────────────┘
      ↓
  错误报告和通知
      ↓
  错误恢复（如果可能）

  7.2.3 错误恢复策略

  自动恢复：

  通信错误恢复：
  1. 检测到通信超时
  2. 尝试重新发送（最多3次）
  3. 如果失败，尝试重新连接
  4. 如果仍失败，进入离线模式

  位置超限恢复：
  1. 检测到超限位
  2. 立即停止运动
  3. 生成回退轨迹（返回安全区域）
  4. 执行回退
  5. 恢复正常控制

  过流恢复：
  1. 检测到过流
  2. 降低速度到50%
  3. 监控电流变化
  4. 如果电流正常，逐步恢复速度
  5. 如果持续过流，停止运动

  手动恢复：

  需要用户干预的情况：
  - 硬件故障
  - 机械卡死
  - 严重碰撞
  - 配置错误

  恢复步骤：
  1. 系统进入安全状态（停止运动）
  2. 显示错误信息和建议操作
  3. 等待用户确认
  4. 用户排除故障
  5. 用户点击"复位"按钮
  6. 系统自检
  7. 恢复正常运行

  7.3 急停机制

  急停触发条件：
  - 用户按下急停按钮
  - 检测到严重错误
  - 硬件急停信号
  - 看门狗超时

  急停执行流程：

  急停触发
      ↓
  1. 立即停止发送新指令
      ↓
  2. 清空轨迹缓冲区
      ↓
  3. 发送紧急停止指令到硬件
      ↓
  4. 等待硬件确认停止
      ↓
  5. 记录急停事件和当前状态
      ↓
  6. 进入急停状态（锁定所有控制）
      ↓
  7. 显示急停提示
      ↓
  8. 等待用户复位

  急停恢复：

  用户点击"复位"按钮
      ↓
  1. 检查急停原因是否已解决
      ↓
  2. 执行系统自检
      ↓
  3. 验证硬件状态
      ↓
  4. 如果一切正常：- 解除急停状态
     - 恢复控制权限
     - 记录恢复事件
      ↓
  5. 如果仍有问题：
     - 显示错误信息
     - 保持急停状态

  ---
  8. 性能指标

  8.1 实时性指标

  | 指标           | 目标值     | 测量方法           |
  |----------------|------------|--------------------|
  | 控制频率       | 200Hz ± 5% | 统计实际循环周期   |
  | 控制周期抖动   | < 1ms      | 测量周期标准差     |
  | 通信延迟       | < 10ms     | 发送到接收的时间差 |
  | UI响应延迟     | < 100ms    | 用户操作到UI更新   |
  | 轨迹生成时间   | < 50ms     | 生成200个点的时间  |
  | 运动学求解时间 | < 20µs     | 单次IK求解时间     |

  8.2 精度指标

  | 指标         | 目标值    | 测量方法               |
  |--------------|-----------|------------------------|
  | 位置精度     | ± 5 单位  | 目标位置 vs 实际位置   |
  | 重复定位精度 | ± 2 单位  | 多次到达同一位置的偏差 |
  | 轨迹跟踪误差 | < 10 单位 | 规划轨迹 vs 实际轨迹   |
  | 速度控制精度 | ± 10%     | 目标速度 vs 实际速度   |

  8.3 可靠性指标

  | 指标             | 目标值  | 测量方法                      |
  |------------------|---------|-------------------------------|
  | 通信成功率       | > 99.9% | 成功帧数 / 总帧数             |
  | 系统稳定运行时间 | > 8小时 | 连续运行无崩溃                |
  | 错误恢复成功率   | > 95%   | 自动恢复成功次数 / 总错误次数 |
  | 数据记录完整性   | 100%    | 无数据丢失                    |

  8.4 资源占用指标

  | 指标         | 目标值          | 测量方法         |
  |--------------|-----------------|------------------|
  | CPU占用率    | < 30%           | 平均CPU使用率    |
  | 内存占用     | < 500MB         | 稳定运行时的内存 |
  | 磁盘空间     | < 100MB（程序） | 安装大小         |
  | 日志文件大小 | < 50MB/天       | 日志增长速度     |

  ---
  9. 开发路线图

  9.1 阶段划分

  阶段1：基础框架搭建（第1-2周）

  目标： 建立基本的系统架构和核心模块

  任务清单：
  - 项目结构搭建
  - 配置管理模块实现
  - 日志系统实现
  - 消息总线实现
  - 基础UI框架搭建
  - 串口通信模块实现
  - 协议编解码器实现
  - 单元测试框架搭建

  交付物：
  - 可运行的基础框架
  - 能够连接硬件并收发数据
  - 基本的UI界面

  ---
  阶段2：运动控制核心（第3-4周）

  目标： 实现平滑的运动控制功能

  任务清单：
  - 轨迹规划器实现
    - 线性插值
    - 三次样条插值
    - 梯形速度曲线
  - 插值引擎实现
  - 控制循环实现
  - 运动学求解器集成（Robotics Toolbox）
  - 手动控制模式实现
  - 轨迹模式实现
  - 安全检查模块实现

  交付物：
  - 能够平滑控制机器人运动
  - 支持手动和轨迹两种模式
  - 基本的安全保护功能

  ---
  阶段3：高级功能（第5-6周）

  目标： 添加高级控制功能和用户体验优化

  任务清单：
  - 示教模式实现
  - 脚本模式实现
  - 运动序列编辑器
  - 数据可视化面板
  - 参数调优界面
  - 数据记录和回放功能
  - 预设配置管理
  - 错误处理和恢复机制完善

  交付物：
  - 完整的四种控制模式
  - 丰富的数据可视化
  - 完善的参数调优工具

  ---
  阶段4：测试和优化（第7-8周）

  目标： 全面测试和性能优化

  任务清单：
  - 单元测试覆盖率 > 80%
  - 集成测试
  - 性能测试和优化
  - 压力测试（长时间运行）
  - 边界条件测试
  - 错误注入测试
  - 用户体验优化
  - 文档编写

  交付物：
  - 稳定可靠的系统
  - 完整的测试报告
  - 用户手册和开发文档

  ---
  9.2 里程碑

  | 里程碑           | 时间    | 标志                   |
  |------------------|---------|------------------------|
  | M1: 基础框架完成 | 第2周末 | 能够连接硬件并收发数据 |
  | M2: 平滑控制实现 | 第4周末 | 机器人能够平滑运动     |
  | M3: 功能完整     | 第6周末 | 所有计划功能实现       |
  | M4: 系统发布     | 第8周末 | 通过所有测试，可交付   |

  9.3 风险缓解计划

  技术风险：

  | 风险              | 概率 | 影响 | 缓解措施                   |
  |-------------------|------|------|----------------------------|
  | 运动学库集成困难  | 中   | 高   | 提前验证，准备备选方案     |
  | 实时性能不达标    | 中   | 高   | 早期性能测试，优化关键路径 |
  | 硬件通信不稳定    | 高   | 中   | 增强错误处理，添加重试机制 |
  | Windows兼容性问题 | 低   | 中   | 使用跨平台库，早期测试     |

  进度风险：

  | 风险         | 概率 | 影响 | 缓解措施                 |
  |--------------|------|------|--------------------------|
  | 需求变更     | 中   | 中   | 模块化设计，预留扩展接口 |
  | 技术难题延期 | 中   | 高   | 设置缓冲时间，优先级排序 |
  | 测试时间不足 | 高   | 高   | 持续集成，边开发边测试   |

  ---
  10. 技术风险评估

  10.1 技术可行性分析

  ✅ 高可行性：
  - PyQt5在Windows上成熟稳定
  - Robotics Toolbox功能完善
  - 串口通信技术成熟
  - 轨迹规划算法有现成实现

  ⚠️ 中等风险：
  - 200Hz控制频率在Python中需要优化
  - 运动学求解性能需要验证
  - 多线程同步需要仔细设计

  ❌ 低风险：
  - 无硬实时要求（可接受5-10ms抖动）
  - 无复杂的动力学计算
  - 无需GPU加速

  10.2 性能瓶颈分析

  潜在瓶颈：

  1. Python GIL（全局解释器锁）
    - 影响：多线程性能受限
    - 缓解：使用多进程或C扩展
  2. 串口通信延迟
    - 影响：反馈延迟
    - 缓解：增大缓冲区，优化协议
  3. UI更新开销
    - 影响：占用CPU资源
    - 缓解：降低UI刷新频率，异步更新
  4. 数据记录IO
    - 影响：磁盘IO阻塞
    - 缓解：异步写入，批量写入

  10.3 备选方案

  如果性能不达标：

  方案1：关键模块C/C++重写
  - 将控制循环用C++实现
  - 通过Python绑定调用
  - 预期性能提升：5-10倍

  方案2：使用Cython优化
  - 将关键函数编译为C代码
  - 保持Python接口
  - 预期性能提升：2-5倍

  方案3：降低控制频率
  - 从200Hz降低到100Hz
  - 仍能满足平滑控制需求
  - 降低系统负载

  ---
  11. 总结

  11.1 方案优势

  技术优势：
  - ✅ 轻量级架构：无需复杂的ROS框架
  - ✅ Windows原生支持：完美兼容Windows平台
  - ✅ 快速开发：8周完成全部功能
  - ✅ 易于调试：纯Python实现，调试友好
  - ✅ 模块化设计：易于扩展和维护
  - ✅ 专业运动学：使用成熟的Robotics Toolbox
  - ✅ 丰富算法：参考PythonRobotics实现

  功能优势：
  - ✅ 平滑控制：多种插值算法，满足不同场景
  - ✅ 多种模式：手动、轨迹、示教、脚本四种模式
  - ✅ 实时监控：丰富的数据可视化
  - ✅ 参数调优：灵活的配置管理
  - ✅ 安全可靠：多层安全保护机制

  11.2 适用场景

  最适合：
  - ✅ 机器人调试和测试
  - ✅ 算法验证和参数调优
  - ✅ 教学和演示
  - ✅ 小批量生产

  不太适合：
  - ❌ 需要硬实时的场景（<1ms抖动）
  - ❌ 大规模工业生产
  - ❌ 需要复杂传感器融合的场景

  11.3 后续扩展方向

  短期扩展（3-6个月）：
  - 添加力控制功能
  - 集成视觉系统
  - 添加更多轨迹算法
  - 优化性能

  长期扩展（6-12个月）：
  - 迁移到ROS2（如果需要）
  - 添加仿真功能（集成PyBullet）
  - 支持多机器人协同
  - 云端监控和远程控制

  ---
  附录

  A. 项目文件结构

  evobot_control_system/
  ├── config/                      # 配置文件
  │   ├── robot_config.yaml       # 机器人配置
  │   ├── presets/                # 预设配置
  │   │   ├── high_speed.yaml
  │   │   ├── smooth.yaml
  │   │   └── precision.yaml
  │   └── user_config.yaml        # 用户自定义配置
  ├── src/                         # 源代码
  │   ├── core/                    # 核心模块
  │   │   ├── motion_controller.py
  │   │   ├── trajectory_planner.py
  │   │   ├── kinematics_solver.py
  │   │   └── interpolation_engine.py
  │   ├── hardware/                # 硬件抽象层
  │   │   ├── hardware_manager.py
  │   │   ├── serial_manager.py
  │   │   ├── protocol_codec.py
  │   │   └── status_monitor.py
  │   ├── application/             # 应用层
  │   │   ├── control_mode_manager.py
  │   │   ├── sequence_editor.py
  │   │   └── data_logger.py
  │   ├── ui/                      # 用户界面
  │   │   ├── main_window.py
  │   │   ├── parameter_tuning_window.py
  │   │   ├── visualization_panel.py
  │   │   └── resources/          # UI资源
  │   ├── utils/                   # 工具模块
  │   │   ├── config_manager.py
  │   │   ├── message_bus.py
  │   │   ├── logger.py
  │   │   └── validators.py
  │   └── main.py                  # 程序入口
  ├── tests/                       # 测试代码
  │   ├── unit/                    # 单元测试
  │   ├── integration/             # 集成测试
  │   └── performance/             # 性能测试
  ├── docs/                        # 文档
  │   ├── user_manual.md          # 用户手册
  │   ├── developer_guide.md      # 开发指南
  │   └── api_reference.md        # API参考
  ├── data/                        # 数据目录
  │   ├── logs/                    # 日志文件
  │   ├── recordings/              # 录制数据
  │   └── sequences/               # 运动序列
  ├── requirements.txt             # Python依赖
  ├── setup.py                     # 安装脚本
  └── README.md                    # 项目说明

  B. 依赖库清单

  # requirements.txt

  # 核心依赖
  numpy>=1.24.0
  scipy>=1.10.0
  roboticstoolbox-python>=1.1.0

  # UI框架
  PyQt5>=5.15.0
  pyqtgraph>=0.13.0

  # 通信
  pyserial>=3.5

  # 数据处理
  pandas>=2.0.0
  matplotlib>=3.7.0

  # 配置管理
  pyyaml>=6.0

  # 日志
  loguru>=0.7.0

  # 测试
  pytest>=7.4.0
  pytest-cov>=4.1.0
  pytest-qt>=4.2.0

  # 代码质量
  black>=23.0.0
  flake8>=6.0.0
  mypy>=1.4.0

  C. 关键性能参数参考值